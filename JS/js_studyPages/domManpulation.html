<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript DOM Manipulation Examples (In-Depth)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        background-color: #f0f0f0;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        text-align: center;
      }

      .example {
        margin-bottom: 20px;
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 8px;
        background-color: #f9f9f9;
      }

      h2 {
        margin-top: 0;
      }

      p {
        margin-bottom: 10px;
      }

      ul {
        margin-left: 20px;
      }

      .code-input {
        width: calc(100% - 22px);
        height: 220px;
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        resize: vertical;
        font-family: monospace;
        white-space: pre;
      }

      .console-output {
        border: 1px solid #ccc;
        padding: 10px;
        height: 220px;
        overflow-y: scroll;
        background-color: #1e1e1e;
        color: #dcdcdc;
        border-radius: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      }

      .run-button {
        display: block;
        margin-top: 10px;
        padding: 8px 16px;
        background-color: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .run-button:hover {
        background-color: #0056b3;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>JavaScript DOM Manipulation Examples (In-Depth)</h1>

      <!-- Overview Section -->
      <div class="example">
        <h2>Overview: DOM &amp; DOM Manipulation</h2>
        <p>
          The <strong>Document Object Model (DOM)</strong> is a tree-like
          representation of HTML documents. Each element, attribute, text node,
          and comment is represented as a <em>node</em>. JavaScript can access
          and manipulate this tree to dynamically change the structure, style,
          and content of a webpage.
        </p>
        <p><strong>Quick Rules of Thumb:</strong></p>
        <ul>
          <li>
            <code>document.getElementById</code> is the fastest for selecting a
            single element by its <code>id</code>. It returns
            <code>null</code> if not found.
          </li>
          <li>
            <code>document.getElementsByClassName</code> and
            <code>getElementsByTagName</code> return live
            <em>HTMLCollections</em> that update automatically when the DOM
            changes—use with caution in loops.
          </li>
          <li>
            <code>document.querySelector</code> (first match) and
            <code>querySelectorAll</code> (static NodeList of all matches) allow
            CSS selectors—<code>querySelectorAll</code> returns a static list
            that does not update.
          </li>
          <li>
            Cache references to frequently accessed elements in variables to
            avoid repeated DOM queries (e.g.,
            <code>const header = document.getElementById('header');</code>).
          </li>
          <li>
            Use <code>document.createElement</code> +
            <code>appendChild</code> (or
            <code>append</code>/<code>insertBefore</code>) to add nodes.
            Minimizing <code>innerHTML</code> assignments prevents unnecessary
            re-parsing and potential security risks.
          </li>
          <li>
            Batch multiple operations with a <code>DocumentFragment</code> or
            detach an element before massive updates to minimize reflows and
            repaints.
          </li>
          <li>
            Use <code>textContent</code> (plain text) over
            <code>innerHTML</code> (HTML parsing) for user-generated content to
            avoid XSS.
          </li>
        </ul>
        <p><strong>Quick Tips &amp; Common Pitfalls:</strong></p>
        <ul>
          <li>
            Modifying <code>innerHTML</code> wipes out child nodes and attached
            event listeners. Use <code>element.replaceChild</code> or
            <code>element.insertAdjacentHTML</code> suitably.
          </li>
          <li>
            Use <code>classList.add/remove/toggle</code>—never manually
            concatenate <code>className</code>, which can cause spacing errors.
          </li>
          <li>
            When iterating over live <code>HTMLCollection</code>, its length may
            change as you add/remove elements—convert to an array via
            <code>Array.from</code> or use static <code>querySelectorAll</code>.
          </li>
          <li>
            Event listeners persist even if the node is removed; always call
            <code>removeEventListener</code> or rely on event delegation on a
            parent container.
          </li>
          <li>
            To prevent default behaviors (e.g., link navigation or form
            submission), call <code>event.preventDefault()</code> in an event
            handler.
          </li>
          <li>
            Beware of reflows and repaints—group style changes or use CSS
            classes rather than multiple inline style modifications.
          </li>
        </ul>
        <p><strong>Final Tips:</strong></p>
        <ul>
          <li>
            Use <code>event delegation</code> to handle many similar child
            elements—attach one listener to a parent and check
            <code>event.target</code> with <code>matches()</code>.
          </li>
          <li>
            <code>throttle</code> or <code>debounce</code> scroll/resize/event
            handlers to limit execution frequency.
          </li>
          <li>
            For animations, use <code>requestAnimationFrame</code> instead of
            <code>setTimeout</code> for smoother frame rendering.
          </li>
          <li>
            Leverage CSS transitions and classes for style changes, reducing
            JavaScript work.
          </li>
        </ul>
        <p>
          <strong>Fun Fact:</strong> Modern engines optimize
          <code>querySelectorAll</code> natively, making it competitive with
          <code>getElementById</code> for complex selectors—meaning readability
          often wins over micro-optimizations.
        </p>
      </div>

      <!-- Example 1: Selecting & Understanding Node Collections -->
      <div class="example">
        <h2>Example 1: Selecting &amp; Understanding Node Collections</h2>
        <p>
          Explore the differences between various selection methods, collection
          types, and live vs. static lists. This example is self-contained and
          creates its own elements to demonstrate.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example1-code">
// Step 1: Create a unique container for this example
const ex1Container = document.getElementById("ex1Container") 
  || document.createElement("div");
ex1Container.id = "ex1Container";
if (!ex1Container.parentNode) {
  document.body.appendChild(ex1Container);
}
ex1Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a list of items inside ex1Container
const ul = document.createElement("ul");
ul.id = "ex1DemoList";
const labels = ["Alpha", "Beta", "Gamma"];
labels.forEach(text => {
  const li = document.createElement("li");
  li.className = "ex1DemoItem";
  li.setAttribute("data-value", text.toLowerCase());
  li.textContent = text;
  ul.appendChild(li);
});
ex1Container.appendChild(ul);

// Step 3: getElementById (fast, single element)
const listById = document.getElementById("ex1DemoList");
console.log("getElementById returns:", listById.tagName); // UL

// Step 4: getElementsByClassName (live HTMLCollection)
const itemsByClass = document.getElementsByClassName("ex1DemoItem");
console.log("getElementsByClassName length (initial):", itemsByClass.length); // 3

// Add a new item to demonstrate live collection
const newLi = document.createElement("li");
newLi.className = "ex1DemoItem";
newLi.textContent = "Delta";
ul.appendChild(newLi);
console.log("After appending, HTMLCollection length:", itemsByClass.length); // 4 (live update)

// Step 5: getElementsByTagName (live HTMLCollection)
const itemsByTag = document.getElementsByTagName("li");
console.log("getElementsByTagName length (all li on page):", itemsByTag.length);

// Step 6: querySelectorAll (static NodeList)
const itemsQueryAll = document.querySelectorAll(".ex1DemoItem");
console.log("querySelectorAll length (initial):", itemsQueryAll.length); // 4

// Append another item to show NodeList is static
const anotherLi = document.createElement("li");
anotherLi.className = "ex1DemoItem";
anotherLi.textContent = "Epsilon";
ul.appendChild(anotherLi);
console.log("After appending, NodeList length remains:", itemsQueryAll.length); // still 4

// Step 7: Converting collections to arrays
const itemsArray = Array.from(document.getElementsByClassName("ex1DemoItem"));
console.log("Array length from HTMLCollection:", itemsArray.length); // 5

// Explanation:
// - getElementsByClassName & getElementsByTagName return live HTMLCollections that reflect DOM changes.
// - querySelectorAll returns a static NodeList that does not update when DOM changes.
// - Converting a live collection to an array via Array.from fixes the snapshot at that time.
      </textarea
        >
        <!-- Placeholder where Example 1’s dynamic content appears -->
        <div id="ex1Container"></div>
        <div class="console-output" id="example1-console"></div>
        <button class="run-button" data-example-id="example1">
          Run Example 1
        </button>
      </div>

      <!-- Example 2: Manipulating Text, HTML, and Attributes -->
      <div class="example">
        <h2>Example 2: Manipulating Text, HTML, and Attributes</h2>
        <p>
          This example creates its own elements and demonstrates
          <code>textContent</code>, <code>innerHTML</code>, dataset, and
          attribute methods in isolation.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example2-code">
// Step 1: Create a unique container
const ex2Container = document.getElementById("ex2Container") 
  || document.createElement("div");
ex2Container.id = "ex2Container";
if (!ex2Container.parentNode) {
  document.body.appendChild(ex2Container);
}
ex2Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a header element with id for manipulation
const header = document.createElement("h2");
header.id = "ex2Header";
header.textContent = "Original Header Text";
ex2Container.appendChild(header);

// Step 3: textContent vs innerHTML
console.log("Original textContent:", header.textContent);
header.textContent = "<em>Changed via textContent</em>";
console.log("After textContent, innerHTML shows escaped:", header.innerHTML);

// Use innerHTML to inject HTML (CAUTION: potential XSS)
header.innerHTML = "<em>Changed via innerHTML</em>";
console.log("After innerHTML, rendered HTML:", header.innerHTML);

// Step 4: Working with dataset (data-* attributes)
header.dataset.info = "DemoInfo";
console.log("Header data-info via getAttribute:", header.getAttribute("data-info"));
console.log("Access via dataset:", header.dataset.info);

// Step 5: setAttribute, getAttribute, removeAttribute
header.setAttribute("title", "Tooltip Text");
console.log("Title attribute:", header.getAttribute("title"));
header.removeAttribute("title");
console.log("After removal, title:", header.getAttribute("title")); // null

// Step 6: classList methods
header.classList.add("ex2Highlight");
console.log("Has class ex2Highlight?", header.classList.contains("ex2Highlight"));
header.classList.toggle("ex2Highlight"); // remove
console.log("Has class after toggle?", header.classList.contains("ex2Highlight"));

// Explanation:
// - textContent sets or reads only text; it escapes HTML, preventing XSS.
// - innerHTML parses HTML tags—use carefully with user input.
// - dataset provides convenient access to data-* attributes as camelCase properties.
// - setAttribute and getAttribute handle arbitrary attributes; removeAttribute deletes them.
// - classList offers add/remove/toggle/contains for robust class manipulation.
      </textarea
        >
        <!-- Placeholder where Example 2’s dynamic content appears -->
        <div id="ex2Container"></div>
        <div class="console-output" id="example2-console"></div>
        <button class="run-button" data-example-id="example2">
          Run Example 2
        </button>
      </div>

      <!-- Example 3: Creating, Cloning, and Inserting Elements -->
      <div class="example">
        <h2>Example 3: Creating, Cloning, and Inserting Elements</h2>
        <p>
          Self-contained creation of elements demonstrating
          <code>createElement</code>, <code>cloneNode</code>, and insertion
          methods (<code>appendChild</code>, <code>insertBefore</code>,
          <code>append</code>, <code>prepend</code>,
          <code>insertAdjacentElement</code>).
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example3-code">
// Step 1: Create a unique container
const ex3Container = document.getElementById("ex3Container") 
  || document.createElement("div");
ex3Container.id = "ex3Container";
if (!ex3Container.parentNode) {
  document.body.appendChild(ex3Container);
}
ex3Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a section element
const section = document.createElement("section");
section.id = "ex3Section";
ex3Container.appendChild(section);

// Step 3: Create and append a header inside the section
const header = document.createElement("h3");
header.textContent = "Dynamically Created Section";
section.appendChild(header);

// Step 4: Create a paragraph with insertAdjacentElement
const para = document.createElement("p");
para.textContent = "This paragraph was inserted adjacent to the header.";
header.insertAdjacentElement("afterend", para);

// Step 5: Clone the paragraph (deep clone) and prepend it
const clonedPara = para.cloneNode(true); // true => deep copy
section.prepend(clonedPara);
console.log("Cloned paragraph text:", clonedPara.textContent);

// Step 6: Insert a notice div before an existing list (Example 1's list, if present)
const demoList = document.getElementById("ex1DemoList");
if (demoList && demoList.parentNode) {
  const notice = document.createElement("div");
  notice.textContent = "Notice: The list below was created in Example 1.";
  demoList.parentNode.insertBefore(notice, demoList);
  console.log("Inserted notice before Example 1's list.");
}

// Explanation:
// - createElement creates a new node unattached until appended.
// - cloneNode(true) makes a deep copy; cloneNode(false) copies only the element itself.
// - appendChild and prepend add children at end or beginning, respectively.
// - insertBefore adds a node before a reference node.
// - insertAdjacentElement options: "beforebegin", "afterbegin", "beforeend", "afterend".
      </textarea
        >
        <!-- Placeholder where Example 3’s dynamic content appears -->
        <div id="ex3Container"></div>
        <div class="console-output" id="example3-console"></div>
        <button class="run-button" data-example-id="example3">
          Run Example 3
        </button>
      </div>

      <!-- Example 4: Removing, Replacing, and Clearing Elements -->
      <div class="example">
        <h2>Example 4: Removing, Replacing, and Clearing Elements</h2>
        <p>
          Demonstrate <code>remove()</code>, <code>removeChild()</code>,
          <code>replaceChild()</code>, and clearing contents with
          <code>innerHTML</code> or <code>textContent</code>. Uses its own
          elements to avoid dependencies.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example4-code">
// Step 1: Create a unique container with its own list
const ex4Container = document.getElementById("ex4Container") 
  || document.createElement("div");
ex4Container.id = "ex4Container";
if (!ex4Container.parentNode) {
  document.body.appendChild(ex4Container);
}
ex4Container.innerHTML = ""; // Clear if rerun

const ul = document.createElement("ul");
ul.id = "ex4List";
["One", "Two", "Three"].forEach(text => {
  const li = document.createElement("li");
  li.className = "ex4Item";
  li.textContent = text;
  ul.appendChild(li);
});
ex4Container.appendChild(ul);

// Step 2: Remove the list item with text "Two" using remove()
const toRemove = Array.from(ul.children).find(li => li.textContent === "Two");
if (toRemove) {
  toRemove.remove();
  console.log("Removed item 'Two'");
}

// Step 3: Replace "Three" with "Replaced"
const oldItem = Array.from(ul.children).find(li => li.textContent === "Three");
if (oldItem && oldItem.parentNode) {
  const newItem = document.createElement("li");
  newItem.className = "ex4Item";
  newItem.textContent = "Replaced";
  oldItem.parentNode.replaceChild(newItem, oldItem);
  console.log("Replaced 'Three' with 'Replaced'");
}

// Step 4: Remove the first child using removeChild
if (ul.firstElementChild) {
  const child = ul.firstElementChild;
  ul.removeChild(child);
  console.log("Removed first child:", child.textContent);
}

// Step 5: Clear entire container using innerHTML
ex4Container.innerHTML = "";
console.log("Cleared ex4Container content");

// Explanation:
// - element.remove() directly removes itself from parent.
// - parent.removeChild(child) removes a specific child from its parent.
// - replaceChild(newNode, oldNode) swaps nodes on parent; oldNode must be a direct child.
// - Setting innerHTML = "" clears all descendants and any attached listeners.
      </textarea
        >
        <!-- Placeholder where Example 4’s dynamic content appears -->
        <div id="ex4Container"></div>
        <div class="console-output" id="example4-console"></div>
        <button class="run-button" data-example-id="example4">
          Run Example 4
        </button>
      </div>

      <!-- Example 5: Event Listeners, Capturing vs. Bubbling, Delegation -->
      <div class="example">
        <h2>Example 5: Event Listeners, Capturing vs. Bubbling, Delegation</h2>
        <p>
          Self-contained demonstration of <code>addEventListener</code> options
          (<code>capture</code> vs. <code>bubble</code>),
          <code>stopPropagation</code>, and event delegation.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example5-code">
// Step 1: Create a unique container
const ex5Container = document.getElementById("ex5Container") 
  || document.createElement("div");
ex5Container.id = "ex5Container";
if (!ex5Container.parentNode) {
  document.body.appendChild(ex5Container);
}
ex5Container.innerHTML = ""; // Clear if rerun

// Step 2: Create parent div and child button for capturing/bubbling demo
const eventContainer = document.createElement("div");
eventContainer.id = "ex5EventContainer";
eventContainer.style.border = "1px solid #333";
eventContainer.style.padding = "10px";
eventContainer.textContent = "Event Container (Click Events Below)";
ex5Container.appendChild(eventContainer);

// Create and style the "Click Me" button
const eventBtn = document.createElement("button");
eventBtn.id = "ex5EventBtn";
eventBtn.textContent = "Click Me";
eventBtn.className = "run-button"; // give it the same blue styling
eventContainer.appendChild(eventBtn);

// Step 3: Add capturing listener on container
eventContainer.addEventListener("click", (e) => {
  console.log("Container listener (capturing) triggered");
}, true); // true => capturing phase

// Step 4: Add bubbling listener on container
eventContainer.addEventListener("click", () => {
  console.log("Container listener (bubbling) triggered");
}, false); // false => bubbling phase

// Step 5: Add listener on button that stops propagation
eventBtn.addEventListener("click", (e) => {
  console.log("Button clicked, stopping propagation");
  e.stopPropagation(); // stops further propagation to container
});

// Step 6: Event delegation example: create a dynamic list within container
const delegatedList = document.createElement("ul");
delegatedList.id = "ex5DelegatedList";
for (let i = 1; i <= 3; i++) {
  const li = document.createElement("li");
  li.className = "ex5DelItem";
  li.textContent = `Delegated Item ${i}`;
  delegatedList.appendChild(li);
}
eventContainer.appendChild(delegatedList);

delegatedList.addEventListener("click", (e) => {
  if (e.target && e.target.matches("li.ex5DelItem")) {
    console.log("Delegated click on:", e.target.textContent);
  }
});

// Step 7: Dynamically add a new delegated item to show delegation works
const dynDelItem = document.createElement("li");
dynDelItem.className = "ex5DelItem";
dynDelItem.textContent = "Dynamically Added Item";
delegatedList.appendChild(dynDelItem);
console.log("Dynamically added delegated item. Click it to see delegation.");

// Explanation:
// - useCapture=true makes the container's capturing listener run before child handlers.
// - Bubbling phase (capture=false) runs after child handlers, as event bubbles up.
// - stopPropagation() prevents further propagation in current phase.
// - Event delegation attaches one listener on parent (delegatedList), filtering using matches().
      </textarea
        >
        <!-- Placeholder where Example 5’s dynamic content appears -->
        <div id="ex5Container"></div>
        <div class="console-output" id="example5-console"></div>
        <button class="run-button" data-example-id="example5">
          Run Example 5
        </button>
      </div>

      <!-- Example 6: Traversing, Filtering, Live vs. Static Lists -->
      <div class="example">
        <h2>Example 6: Traversing, Filtering, Live vs. Static Lists</h2>
        <p>
          Navigate between parents, children, siblings; filter NodeLists;
          contrast live <code>HTMLCollection</code> vs. static
          <code>NodeList</code>. Isolates its own list.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example6-code">
// Step 1: Create a unique container and its own list
const ex6Container = document.getElementById("ex6Container") 
  || document.createElement("div");
ex6Container.id = "ex6Container";
if (!ex6Container.parentNode) {
  document.body.appendChild(ex6Container);
}
ex6Container.innerHTML = ""; // Clear if rerun

const demoUl = document.createElement("ul");
demoUl.id = "ex6DemoList";
["One","Two","Three"].forEach(text => {
  const li = document.createElement("li");
  li.className = "ex6DemoItem";
  li.textContent = text;
  demoUl.appendChild(li);
});
ex6Container.appendChild(demoUl);

// Step 2: Access children (live HTMLCollection)
const liveChildren = demoUl.children;
console.log("Live children count:", liveChildren.length); // 3

// Step 3: Convert live HTMLCollection to static array
const staticChildrenArray = Array.from(liveChildren);
console.log("Static array length:", staticChildrenArray.length); // 3

// Step 4: Traverse to parent, siblings
const firstLi = demoUl.querySelector("li");
if (firstLi) {
  console.log("First item:", firstLi.textContent);
  console.log("Parent tag:", firstLi.parentElement.tagName); // UL
  console.log("Next sibling (element):", firstLi.nextElementSibling?.textContent);
  console.log("Previous sibling:", firstLi.previousElementSibling); // null
}

// Step 5: Filter static NodeList using querySelectorAll
const filteredItems = demoUl.querySelectorAll("li.ex6DemoItem");
console.log("Filtered items (static NodeList):", filteredItems.length); // 3

// Step 6: Demonstrate live updates: append one more li
const extraLi = document.createElement("li");
extraLi.className = "ex6DemoItem";
extraLi.textContent = "Four";
demoUl.appendChild(extraLi);
console.log("After append, liveChildren length:", liveChildren.length); // 4
console.log("staticChildrenArray length remains:", staticChildrenArray.length); // 3

// Explanation:
// - HTMLCollection (liveChildren) reflects DOM changes immediately.
// - NodeLists returned by querySelectorAll are static snapshots.
// - parentElement, nextElementSibling, previousElementSibling allow traversal ignoring text nodes.
      </textarea
        >
        <!-- Placeholder where Example 6’s dynamic content appears -->
        <div id="ex6Container"></div>
        <div class="console-output" id="example6-console"></div>
        <button class="run-button" data-example-id="example6">
          Run Example 6
        </button>
      </div>

      <!-- Example 7: innerHTML vs textContent, Security, and Sanitization -->
      <div class="example">
        <h2>
          Example 7: <code>innerHTML</code> vs <code>textContent</code>,
          Security, and Sanitization
        </h2>
        <p>
          Demonstrates safe vs. unsafe insertion, and a simple sanitization
          approach. Each example runs in its own space.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example7-code">
// Step 1: Create a unique container
const ex7Container = document.getElementById("ex7Container") 
  || document.createElement("div");
ex7Container.id = "ex7Container";
if (!ex7Container.parentNode) {
  document.body.appendChild(ex7Container);
}
ex7Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a safe output div
const safeContainer = document.createElement("div");
safeContainer.id = "ex7SafeContainer";
ex7Container.appendChild(safeContainer);

// Step 3: Simulate user input (potentially malicious)
const userInput = '<img src="x" onerror="console.log(\'XSS Executed\')">';

// Using textContent to escape HTML
safeContainer.textContent = userInput;
console.log("textContent output (escaped):", safeContainer.innerHTML);

// Using innerHTML without sanitization (unsafe)
try {
  safeContainer.innerHTML = userInput;
  console.log("innerHTML output (unsafe, executes XSS if allowed)");
} catch (e) {
  console.error("Error setting innerHTML:", e.message);
}

// Step 4: Basic sanitization function (removes <script> tags)
function sanitizeHTML(str) {
  return str.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, "");
}

// Simulate sanitization before innerHTML
const malicious = '<div>Safe<span onclick="alert(\'evil\')">Click</span><script>alert("bad")</script></div>';
const clean = sanitizeHTML(malicious);
safeContainer.innerHTML = clean;
console.log("After sanitization, innerHTML:", safeContainer.innerHTML);

// Explanation:
// - textContent sets plain text, escaping any HTML tags, preventing XSS.
// - innerHTML parses and renders HTML; unsanitized user input can lead to XSS.
// - Basic sanitization removes <script> tags; full sanitization requires robust libraries (e.g., DOMPurify).
      </textarea
        >
        <!-- Placeholder where Example 7’s dynamic content appears -->
        <div id="ex7Container"></div>
        <div class="console-output" id="example7-console"></div>
        <button class="run-button" data-example-id="example7">
          Run Example 7
        </button>
      </div>

      <!-- Example 8: Performance Optimization with DocumentFragment -->
      <div class="example">
        <h2>
          Example 8: Performance Optimization with <code>DocumentFragment</code>
        </h2>
        <p>
          Inserts multiple nodes efficiently by using
          <code>DocumentFragment</code> to minimize reflows and repaints.
          Self-contained elements are used.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example8-code">
// Step 1: Create a unique container for performance test
const ex8Container = document.getElementById("ex8Container") 
  || document.createElement("div");
ex8Container.id = "ex8Container";
if (!ex8Container.parentNode) {
  document.body.appendChild(ex8Container);
}
ex8Container.innerHTML = ""; // Clear if rerun

const perfContainer = document.createElement("div");
perfContainer.style.border = "1px solid #666";
perfContainer.style.padding = "10px";
perfContainer.textContent = "Performance Test:";
ex8Container.appendChild(perfContainer);

const perfUl = document.createElement("ul");
perfUl.id = "ex8PerfUl";
perfContainer.appendChild(perfUl);

// Step 2: Append 20 list items directly (triggers reflow each append)
console.time("DirectAppend");
for (let i = 0; i < 20; i++) {
  const li = document.createElement("li");
  li.textContent = `Direct Item ${i}`;
  perfUl.appendChild(li); // each append forces reflow/repaint
}
console.timeEnd("DirectAppend");

// Clear the list
perfUl.innerHTML = "";

// Step 3: Use DocumentFragment to append 20 items at once
console.time("FragmentAppend");
const fragment = document.createDocumentFragment();
for (let i = 0; i < 20; i++) {
  const li = document.createElement("li");
  li.textContent = `Fragment Item ${i}`;
  fragment.appendChild(li); // in-memory, no reflow yet
}
perfUl.appendChild(fragment); // single reflow/repaint
console.timeEnd("FragmentAppend");

// Explanation:
// - Direct appends call appendChild each iteration, causing repeated reflows.
// - DocumentFragment is an in-memory container; building all nodes there and appending once reduces layout thrash.
      </textarea
        >
        <!-- Placeholder where Example 8’s dynamic content appears -->
        <div id="ex8Container"></div>
        <div class="console-output" id="example8-console"></div>
        <button class="run-button" data-example-id="example8">
          Run Example 8
        </button>
      </div>

      <!-- Example 9: Event Listener Removal, Memory Leak Prevention -->
      <div class="example" id="example9-wrapper">
        <h2>Example 9: Event Listener Removal, Memory Leak Prevention</h2>
        <p>
          Properly remove event listeners when elements are removed, preventing
          memory leaks and detached references. Uses unique elements.
        </p>
        <!-- Placeholder where Example 9’s dynamic content appears -->
        <div id="ex9Container"></div>
        <!-- console / run-button row -->
        <div style="display: flex; align-items: center; gap: 10px">
          <div
            class="console-output"
            id="example9-console"
            style="flex: 1"
          ></div>
          <div>
            <button class="run-button" id="run-example9">Run Example 9</button>
            <!-- Placeholder for “Click & Remove” -->
            <button
              class="run-button"
              id="click-remove-btn"
              style="display: none; margin-top: 5px"
            >
              Click & Remove
            </button>
          </div>
        </div>
      </div>

      <!-- Example 10: Complex TODO List with Validation, Styling, and Delegation -->
      <div class="example">
        <h2>
          Example 10: Complex TODO List with Validation, Styling, and Delegation
        </h2>
        <p>
          A full-fledged example combining element creation, input validation,
          class manipulations, event delegation, and CSS styling. Everything is
          self-contained.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example10-code">
// Step 1: Create a unique container for TODO list
const ex10Container = document.getElementById("ex10Container") 
  || document.createElement("div");
ex10Container.id = "ex10Container";
if (!ex10Container.parentNode) {
  document.body.appendChild(ex10Container);
}
ex10Container.innerHTML = ""; // Clear if rerun

// Step 2: Create input, button, and ul for TODO list
const todoDiv = document.createElement("div");
todoDiv.id = "ex10TodoDiv";
ex10Container.appendChild(todoDiv);

const todoInput = document.createElement("input");
todoInput.id = "ex10TodoInput";
todoInput.placeholder = "Enter TODO item (2-20 chars)";
todoDiv.appendChild(todoInput);

const todoBtn = document.createElement("button");
todoBtn.id = "ex10TodoBtn";
todoBtn.textContent = "Add Item";
todoDiv.appendChild(todoBtn);

const todoUl = document.createElement("ul");
todoUl.id = "ex10TodoUl";
todoDiv.appendChild(todoUl);

// Step 3: Styling via class addition
const style = document.createElement("style");
style.textContent = `
  #ex10TodoDiv { margin: 20px 0; }
  #ex10TodoInput { padding: 5px; width: 200px; }
  #ex10TodoBtn { padding: 5px 10px; margin-left: 5px; }
  #ex10TodoUl li { margin: 5px 0; display: flex; align-items: center; }
  #ex10TodoUl li.done { text-decoration: line-through; color: gray; }
  button.ex10DeleteBtn { margin-left: 10px; color: red; }
`;
document.head.appendChild(style);

// Step 4: Input validation function
function validateTodo(text) {
  if (typeof text !== "string") {
    console.warn("Validation failed: Input is not a string.");
    return false;
  }
  const trimmed = text.trim();
  if (trimmed.length < 2 || trimmed.length > 20) {
    console.warn("Validation failed: Length must be between 2 and 20.");
    return false;
  }
  return true;
}

// Step 5: Event listener to add new TODO item
todoBtn.addEventListener("click", () => {
  const value = todoInput.value;
  if (!validateTodo(value)) {
    return; // invalid input, exit early
  }
  const li = document.createElement("li");
  li.textContent = value.trim();

  // Toggle done state on click
  li.addEventListener("click", () => {
    li.classList.toggle("done");
    console.log("Toggled done for:", li.textContent);
  });

  // Create delete button
  const delBtn = document.createElement("button");
  delBtn.textContent = "Delete";
  delBtn.className = "ex10DeleteBtn";
  // Deleting item on click
  delBtn.addEventListener("click", (e) => {
    e.stopPropagation(); // prevent li click event
    todoUl.removeChild(li);
    console.log("Deleted item:", li.textContent);
  });

  li.appendChild(delBtn);
  todoUl.appendChild(li);
  console.log("Added TODO item:", li.textContent);
  todoInput.value = ""; // clear input
});

// Step 6: Event delegation alternative (commented out for demonstration)
/*
todoUl.addEventListener("click", (e) => {
  if (e.target.matches("li")) {
    e.target.classList.toggle("done");
    console.log("Toggled done via delegation:", e.target.textContent);
  }
  if (e.target.matches("button.ex10DeleteBtn")) {
    const li = e.target.parentElement;
    todoUl.removeChild(li);
    console.log("Deleted via delegation:", li.textContent);
  }
});
*/

// Explanation:
// - validateTodo checks type and length, logging warnings via console.warn for invalid input.
// - Each <li> gets its own click handler to toggle <code>done</code> class for styling (line-through).
// - delete button stops propagation so clicking it doesn’t also toggle done on the <li>.
// - Demonstrates event delegation (commented out) as an alternative to attaching individual listeners.
// - Styling is added dynamically via a <code>&lt;style&gt;</code> block with CSS classes.
      </textarea
        >
        <!-- Placeholder where Example 10’s dynamic content appears -->
        <div id="ex10Container"></div>
        <div class="console-output" id="example10-console"></div>
        <button class="run-button" data-example-id="example10">
          Run Example 10
        </button>
      </div>

      <!-- Example 11: innerHTML / textContent on Page (PDF Integration) -->
      <div class="example">
        <h2>
          Example 11: <code>innerHTML</code> vs <code>textContent</code> on Page
        </h2>
        <p>
          Demonstrate modifying page content directly using
          <code>innerHTML</code> vs <code>textContent</code>, as shown in the
          PDF.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example11-code">
// Step 1: Create a unique container for this example
const ex11Container = document.getElementById("ex11Container") 
  || document.createElement("div");
ex11Container.id = "ex11Container";
if (!ex11Container.parentNode) {
  document.body.appendChild(ex11Container);
}
ex11Container.innerHTML = ""; // Clear if rerun

// Step 2: Create an element with innerHTML and textContent demonstration
const demoDiv = document.createElement("div");
demoDiv.id = "ex11DemoDiv";
demoDiv.textContent = "Original TextContent";
ex11Container.appendChild(demoDiv);

// Log original states
console.log("Original textContent:", demoDiv.textContent);
console.log("Original innerHTML:", demoDiv.innerHTML);

// Change using textContent
demoDiv.textContent = "<strong>Changed via textContent</strong>";
console.log("After textContent, demoDiv.innerHTML:", demoDiv.innerHTML);

// Change using innerHTML
demoDiv.innerHTML = "<strong>Changed via innerHTML</strong>";
console.log("After innerHTML, demoDiv.innerHTML:", demoDiv.innerHTML);
      </textarea
        >
        <!-- Placeholder where Example 11’s dynamic content appears -->
        <div id="ex11Container"></div>
        <div class="console-output" id="example11-console"></div>
        <button class="run-button" data-example-id="example11">
          Run Example 11
        </button>
      </div>

      <!-- Example 12: setAttribute & removeAttribute (PDF Integration) -->
      <div class="example">
        <h2>
          Example 12: <code>setAttribute</code> &amp;
          <code>removeAttribute</code>
        </h2>
        <p>
          Demonstrate adding and removing attributes on a link element,
          replicating PDF examples.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example12-code">
// Step 1: Create a unique container for this example
const ex12Container = document.getElementById("ex12Container") 
  || document.createElement("div");
ex12Container.id = "ex12Container";
if (!ex12Container.parentNode) {
  document.body.appendChild(ex12Container);
}
ex12Container.innerHTML = ""; // Clear if rerun

// Step 2: Create an anchor without href
const link = document.createElement("a");
link.id = "ex12Link";
link.textContent = "Click me to go to Persevere";
ex12Container.appendChild(link);

// Initially, link is not clickable
console.log("Initial href:", link.getAttribute("href"));

// Step 3: Set the href attribute
link.setAttribute("href", "https://www.persever.com");
console.log("After setAttribute, href:", link.getAttribute("href"));

// Step 4: Click demonstration (user can click the link in the page)
// Step 5: Remove the href attribute
link.removeAttribute("href");
console.log("After removeAttribute, href:", link.getAttribute("href")); // null
      </textarea
        >
        <!-- Placeholder where Example 12’s dynamic content appears -->
        <div id="ex12Container"></div>
        <div class="console-output" id="example12-console"></div>
        <button class="run-button" data-example-id="example12">
          Run Example 12
        </button>
      </div>

      <!-- Example 13: Manage CSS Classes with classList (PDF Integration) -->
      <div class="example">
        <h2>Example 13: Managing CSS Classes with <code>classList</code></h2>
        <p>
          Demonstrate <code>classList.add</code>, <code>remove</code>, and
          <code>toggle</code>, replicating the PDF.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example13-code">
// Step 1: Create a unique container for this example
const ex13Container = document.getElementById("ex13Container") 
  || document.createElement("div");
ex13Container.id = "ex13Container";
if (!ex13Container.parentNode) {
  document.body.appendChild(ex13Container);
}
ex13Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a placeholder element and CSS style
const placeholder = document.createElement("div");
placeholder.id = "ex13Placeholder";
placeholder.textContent = "Watch my classes change!";
ex13Container.appendChild(placeholder);

// Add CSS style
const styleEx13 = document.createElement("style");
styleEx13.textContent = `
  #ex13Placeholder { padding: 10px; border: 1px solid #333; }
  .highlight { background-color: yellow; }
`;
document.head.appendChild(styleEx13);

// Log initial classList
console.log("Initial classes:", placeholder.classList.toString());

// Step 3: Add class
placeholder.classList.add("highlight");
console.log("After classList.add('highlight'):", placeholder.classList.toString());

// Step 4: Toggle class
placeholder.classList.toggle("highlight");
console.log("After classList.toggle('highlight'):", placeholder.classList.toString());

// Step 5: Remove class (if still exists)
placeholder.classList.remove("highlight");
console.log("After classList.remove('highlight'):", placeholder.classList.toString());
      </textarea
        >
        <!-- Placeholder where Example 13’s dynamic content appears -->
        <div id="ex13Container"></div>
        <div class="console-output" id="example13-console"></div>
        <button class="run-button" data-example-id="example13">
          Run Example 13
        </button>
      </div>

      <!-- Example 14: createElement & appendChild (PDF Integration) -->
      <div class="example">
        <h2>
          Example 14: <code>createElement</code> &amp; <code>appendChild</code>
        </h2>
        <p>
          Demonstrate creating a new div and appending it to the page,
          replicating the PDF.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example14-code">
// Step 1: Create a unique container for this example
const ex14Container = document.getElementById("ex14Container") 
  || document.createElement("div");
ex14Container.id = "ex14Container";
if (!ex14Container.parentNode) {
  document.body.appendChild(ex14Container);
}
ex14Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a new div element
const newDiv = document.createElement("div");
newDiv.textContent = "I am a new div created via createElement!";
newDiv.style.padding = "10px";
newDiv.style.border = "1px solid #000";

// Step 3: Append to the container
ex14Container.appendChild(newDiv);
console.log("New div appended. Inspect the page to see it.");
      </textarea
        >
        <!-- Placeholder where Example 14’s dynamic content appears -->
        <div id="ex14Container"></div>
        <div class="console-output" id="example14-console"></div>
        <button class="run-button" data-example-id="example14">
          Run Example 14
        </button>
      </div>

      <!-- Example 15: insertBefore (PDF Integration) -->
      <div class="example">
        <h2>Example 15: <code>insertBefore</code></h2>
        <p>
          Demonstrate inserting a new element before an existing reference node,
          replicating the PDF.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example15-code">
// Step 1: Create a unique container for this example
const ex15Container = document.getElementById("ex15Container") 
  || document.createElement("div");
ex15Container.id = "ex15Container";
if (!ex15Container.parentNode) {
  document.body.appendChild(ex15Container);
}
ex15Container.innerHTML = ""; // Clear if rerun

// Step 2: Create two paragraphs in the container
const refPara = document.createElement("p");
refPara.id = "refPara";
refPara.textContent = "I am the reference paragraph. The new element will be inserted before me.";
ex15Container.appendChild(refPara);

// Step 3: Create a new paragraph to insert
const newParagraph = document.createElement("p");
newParagraph.textContent = "I am the new paragraph inserted before the reference paragraph.";
newParagraph.style.color = "blue";

// Step 4: Use insertBefore
ex15Container.insertBefore(newParagraph, refPara);
console.log("New paragraph inserted before reference paragraph.");
      </textarea
        >
        <!-- Placeholder where Example 15’s dynamic content appears -->
        <div id="ex15Container"></div>
        <div class="console-output" id="example15-console"></div>
        <button class="run-button" data-example-id="example15">
          Run Example 15
        </button>
      </div>

      <!-- Example 16: removeChild (PDF Integration) -->
      <div class="example">
        <h2>Example 16: <code>removeChild</code></h2>
        <p>
          Demonstrate removing an element from the DOM using
          <code>removeChild</code>, replicating the PDF.
        </p>
        <p><strong>Code:</strong></p>
        <textarea class="code-input" id="example16-code">
// Step 1: Create a unique container for this example
const ex16Container = document.getElementById("ex16Container") 
  || document.createElement("div");
ex16Container.id = "ex16Container";
if (!ex16Container.parentNode) {
  document.body.appendChild(ex16Container);
}
ex16Container.innerHTML = ""; // Clear if rerun

// Step 2: Create a list with some items
const list = document.createElement("ul");
list.id = "ex16List";
["Remove me", "Keep me", "Also keep me"].forEach(text => {
  const li = document.createElement("li");
  li.textContent = text;
  list.appendChild(li);
});
ex16Container.appendChild(list);

// Step 3: Remove the first child using removeChild
const firstItem = list.firstElementChild;
if (firstItem) {
  list.removeChild(firstItem);
  console.log("Removed first list item:", firstItem.textContent);
}
      </textarea
        >
        <!-- Placeholder where Example 16’s dynamic content appears -->
        <div id="ex16Container"></div>
        <div class="console-output" id="example16-console"></div>
        <button class="run-button" data-example-id="example16">
          Run Example 16
        </button>
      </div>
    </div>

    <script>
      document.querySelectorAll(".run-button").forEach((button) => {
        button.addEventListener("click", () => {
          const exampleId = button.getAttribute("data-example-id");
          const code = document.getElementById(`${exampleId}-code`).value;
          const consoleOutput = document.getElementById(`${exampleId}-console`);
          consoleOutput.innerHTML = "";

          try {
            // Backup original console methods
            const originalConsole = { ...console };

            // Override console to capture output consistently
            console.log = function (...args) {
              args.forEach((arg) => {
                let formatted;
                if (typeof arg === "object" && arg !== null) {
                  try {
                    formatted = JSON.stringify(
                      arg,
                      function (key, value) {
                        if (typeof value === "function") {
                          return "[Function]";
                        }
                        return value;
                      },
                      2
                    );
                  } catch {
                    formatted = String(arg);
                  }
                } else {
                  formatted = arg;
                }
                consoleOutput.innerHTML += formatted + "\n";
              });
            };
            console.info = console.log;
            console.warn = console.log;
            console.error = console.log;
            console.debug = console.log;
            console.assert = function (condition, ...args) {
              if (!condition) {
                consoleOutput.innerHTML +=
                  "Assertion failed: " + args.join(" ") + "\n";
              }
            };
            console.dir = function (obj) {
              try {
                const dirStr = JSON.stringify(obj, null, 2);
                consoleOutput.innerHTML += dirStr + "\n";
              } catch {
                consoleOutput.innerHTML += String(obj) + "\n";
              }
            };
            console.trace = function (label = "") {
              try {
                throw new Error("StackTrace");
              } catch (err) {
                consoleOutput.innerHTML +=
                  (label ? label + "\n" : "") + err.stack + "\n";
              }
            };
            console.group = function (label) {
              consoleOutput.innerHTML += `┌─ Group: ${label}\n`;
            };
            console.groupCollapsed = function (label) {
              consoleOutput.innerHTML += `┌─ Group (collapsed): ${label}\n`;
            };
            console.groupEnd = function () {
              consoleOutput.innerHTML += `└─ End Group\n`;
            };
            console.table = function (data) {
              try {
                const table = Array.isArray(data) ? data : [data];
                const cols = Object.keys(table[0] || {});
                consoleOutput.innerHTML += cols.join("\t") + "\n";
                table.forEach((row) => {
                  consoleOutput.innerHTML +=
                    cols.map((c) => row[c]).join("\t") + "\n";
                });
              } catch {
                consoleOutput.innerHTML += String(data) + "\n";
              }
            };
            console.time = function (label) {
              originalConsole.time(label);
              consoleOutput.innerHTML += `Timer started: ${label}\n`;
            };
            console.timeEnd = function (label) {
              originalConsole.timeEnd(label);
              consoleOutput.innerHTML += `Timer ended: ${label}\n`;
            };

            // Execute the code in the editor
            eval(code);

            // After `eval`, if this is Example 5, keep overriding console.log so that future clicks
            // inside Example 5 still log here:
            if (exampleId === "example5") {
              const ex5Console = document.getElementById("example5-console");
              console.log = function (...args) {
                args.forEach((arg) => {
                  let formatted;
                  if (typeof arg === "object" && arg !== null) {
                    try {
                      formatted = JSON.stringify(
                        arg,
                        (k, v) => (typeof v === "function" ? "[Function]" : v),
                        2
                      );
                    } catch {
                      formatted = String(arg);
                    }
                  } else {
                    formatted = arg;
                  }
                  ex5Console.innerHTML += formatted + "\n";
                });
              };
            }

            // Restore original console methods for everything else
            if (exampleId !== "example5") {
              Object.assign(console, originalConsole);
            }
          } catch (error) {
            // Restore console before logging error
            console.log = function () {
              consoleOutput.innerHTML += `Error during execution: ${error.message}\n`;
            };
            console.log();
          }
        });
      });
    </script>

    <!-- Custom script for Example 9 (placed after global runner) -->
    <script>
      document.getElementById("run-example9").addEventListener("click", () => {
        const consoleOutput = document.getElementById("example9-console");
        consoleOutput.textContent = "";

        const clickRemoveBtn = document.getElementById("click-remove-btn");
        // Show the Click & Remove button now that the demo container exists
        clickRemoveBtn.style.display = "inline-block";

        // Backup original console.log
        const originalLog = console.log;
        console.log = (...args) => {
          args.forEach((arg) => {
            if (typeof arg === "object" && arg !== null) {
              try {
                consoleOutput.textContent +=
                  JSON.stringify(arg, null, 2) + "\n";
              } catch {
                consoleOutput.textContent += String(arg) + "\n";
              }
            } else {
              consoleOutput.textContent += arg + "\n";
            }
          });
        };

        // ==== Example 9 code starts here ====
        // Create a unique container for this demo (hidden—it’s only needed to host the removed element)
        const ex9Container =
          document.getElementById("ex9Container") ||
          document.createElement("div");
        ex9Container.id = "ex9Container";
        // Make it not visible on screen
        ex9Container.style.display = "none";
        if (!ex9Container.parentNode) {
          document.body.appendChild(ex9Container);
        }
        ex9Container.innerHTML = ""; // Clear if rerun

        // Create the “Click & Remove” button attachment point
        const leakDiv = document.createElement("div");
        leakDiv.id = "ex9LeakDiv";
        ex9Container.appendChild(leakDiv);

        // Now create the actual button in the hidden container
        const leakBtn = document.createElement("button");
        leakBtn.textContent = "Click & Remove";
        // We will NOT append it here; instead we’ll hook it up to our visible placeholder:
        leakDiv.appendChild(leakBtn);

        // Step 2: Event handler that removes itself and the element
        function handleClick() {
          console.log("Button clicked, removing listener and element.");
          leakBtn.removeEventListener("click", handleClick); // remove listener to prevent leak
          if (leakDiv.parentNode) {
            leakDiv.parentNode.removeChild(leakDiv); // remove the hidden container
          }
          // Hide the visible “Click & Remove” as well
          clickRemoveBtn.style.display = "none";
        }

        // Step 3: Attach listener
        leakBtn.addEventListener("click", handleClick);
        console.log(
          "Demo ready. Press the visible “Click & Remove” to trigger removal."
        );

        // Monkey-patch the visible placeholder so it forwards clicks to our hidden leakBtn
        clickRemoveBtn.onclick = () => leakBtn.click();
        // ==== Example 9 code ends here ====

        // Restore console.log
        console.log = originalLog;
      });
    </script>
  </body>
</html>
